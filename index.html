<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <!-- Three.js（3D场景） -->
<script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>
<!-- MediaPipe（手势识别） -->
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4.1646424915/hands.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils@0.3.1646425229/camera_utils.min.js"></script>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Particle Christmas Tree - Gesture Control</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Arial', sans-serif; }
        #ui-layer {
            position: absolute;
            top: 20px;
            width: 100%;
            text-align: center;
            color: #D4AF37;
            pointer-events: none;
            z-index: 10;
        }
        h1 { font-size: 3rem; margin: 0; text-shadow: 0 0 10px rgba(212, 175, 55, 0.5); }
        .hint { color: #fff; font-size: 0.9rem; opacity: 0.7; }
        
        /* 摄像头预览（小窗） */
        #video-container {
            position: absolute;
            bottom: 10px;
            right: 10px;
            width: 160px;
            height: 120px;
            border: 2px solid #D4AF37;
            border-radius: 8px;
            overflow: hidden;
            transform: scaleX(-1); /* 镜像 */
        }
        video { width: 100%; height: 100%; object-fit: cover; }
        canvas.output_canvas { display: none; }

        #loading {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: #000; display: flex; justify-content: center; align-items: center;
            color: #D4AF37; z-index: 100;
        }
    </style>
</head>
<body>

<div id="loading">正在初始化AI模型和3D场景...</div>

<div id="ui-layer">
    <h1>Merry Christmas</h1>
    <p class="hint">手势说明：捏合(OK手势) = 聚合/放大 | 张开 = 分散/缩小</p>
</div>

<div id="video-container">
    <video class="input_video"></video>
</div>

<!-- 引入依赖库 -->
<script src="https://cdn.jsdelivr.net/npm/three@0.152.0/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>

<script>
/**
 * 配置与初始化
 */
let scene, camera, renderer, particles, photoMesh;
const PARTICLE_COUNT = 3000;
const treePoints = [];
const randomPoints = [];
let isAggregated = false;
let currentScale = 1;

const videoElement = document.getElementsByClassName('input_video')[0];
const loadingScreen = document.getElementById('loading');

// 初始化 Three.js
function initThree() {
    scene = new THREE.Scene();
    camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.z = 5;

    renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    document.body.appendChild(renderer.domElement);

    // 创建粒子
    const geometry = new THREE.BufferGeometry();
    const positions = new Float32Array(PARTICLE_COUNT * 3);
    const colors = new Float32Array(PARTICLE_COUNT * 3);

    for (let i = 0; i < PARTICLE_COUNT; i++) {
        // 圣诞树形状算法 (圆锥螺旋)
        const y = Math.random() * 4 - 2;
        const radius = (2 - y) * 0.5;
        const angle = y * 10 + Math.random() * 0.5;
        
        const tx = Math.cos(angle) * radius * Math.random();
        const ty = y;
        const tz = Math.sin(angle) * radius * Math.random();
        
        treePoints.push(new THREE.Vector3(tx, ty, tz));
        randomPoints.push(new THREE.Vector3(
            (Math.random() - 0.5) * 10,
            (Math.random() - 0.5) * 10,
            (Math.random() - 0.5) * 10
        ));

        positions[i * 3] = randomPoints[i].x;
        positions[i * 3 + 1] = randomPoints[i].y;
        positions[i * 3 + 2] = randomPoints[i].z;

        // 金色配色
        colors[i * 3] = 0.83;     // R: 212
        colors[i * 3 + 1] = 0.68; // G: 175
        colors[i * 3 + 2] = 0.21; // B: 55
    }

    geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
    geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

    const material = new THREE.PointsMaterial({
        size: 0.02,
        vertexColors: true,
        transparent: true,
        blending: THREE.AdditiveBlending
    });

    particles = new THREE.Points(geometry, material);
    scene.add(particles);

    // 添加照片 (占位图)
    const loader = new THREE.TextureLoader();
    // 这里可以替换为你自己的照片URL
    const photoTex = loader.load('https://picsum.photos/400/400'); 
    const photoGeo = new THREE.PlaneGeometry(1.5, 1.5);
    const photoMat = new THREE.MeshBasicMaterial({ map: photoTex, transparent: true, opacity: 0 });
    photoMesh = new THREE.Mesh(photoGeo, photoMat);
    photoMesh.position.z = 1;
    scene.add(photoMesh);

    window.addEventListener('resize', onWindowResize, false);
}

function onWindowResize() {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
}

/**
 * 手势识别逻辑
 */
function onResults(results) {
    if (loadingScreen) loadingScreen.style.display = 'none';

    if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
        const landmarks = results.multiHandLandmarks[0];
        
        // 计算食指尖(8)和拇指尖(4)的距离
        const thumbTip = landmarks[4];
        const indexTip = landmarks[8];
        const distance = Math.sqrt(
            Math.pow(thumbTip.x - indexTip.x, 2) +
            Math.pow(thumbTip.y - indexTip.y, 2)
        );

        // 捏合/OK手势判定 (距离小于 0.05)
        if (distance < 0.05) {
            isAggregated = true;
            currentScale = 1.5; // 放大
            photoMesh.material.opacity = Math.min(photoMesh.material.opacity + 0.05, 1);
        } else {
            isAggregated = false;
            currentScale = 1.0; // 还原
            photoMesh.material.opacity = Math.max(photoMesh.material.opacity - 0.05, 0);
        }

        // 手势控制照片位置 (映射到屏幕中心)
        photoMesh.position.x = (0.5 - indexTip.x) * 5;
        photoMesh.position.y = (0.5 - indexTip.y) * 5;
    }
}

const hands = new Hands({
    locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
});

hands.setOptions({
    maxNumHands: 1,
    modelComplexity: 1,
    minDetectionConfidence: 0.5,
    minTrackingConfidence: 0.5
});
hands.onResults(onResults);

const cameraUtils = new Camera(videoElement, {
    onFrame: async () => {
        await hands.send({ image: videoElement });
    },
    width: 640,
    height: 480
});
cameraUtils.start();

/**
 * 动画循环
 */
function animate() {
    requestAnimationFrame(animate);

    const positions = particles.geometry.attributes.position.array;
    
    for (let i = 0; i < PARTICLE_COUNT; i++) {
        const target = isAggregated ? treePoints[i] : randomPoints[i];
        
        // 平滑插值动画 (Lerp)
        positions[i * 3] += (target.x - positions[i * 3]) * 0.1;
        positions[i * 3 + 1] += (target.y - positions[i * 3 + 1]) * 0.1;
        positions[i * 3 + 2] += (target.z - positions[i * 3 + 2]) * 0.1;
    }
    
    particles.geometry.attributes.position.needsUpdate = true;
    particles.rotation.y += 0.005; // 持续自转
    
    // 缩放动画
    const targetScale = isAggregated ? 1.5 : 1.0;
    particles.scale.lerp(new THREE.Vector3(targetScale, targetScale, targetScale), 0.1);
    photoMesh.scale.lerp(new THREE.Vector3(targetScale, targetScale, targetScale), 0.1);

    renderer.render(scene, camera);
}

// 启动
initThree();
animate();
</script>
</body>
</html>
